{"version":3,"sources":["index.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["/**\r\n * Expose `pathToRegexp`.\r\n */\r\n\r\nmodule.exports = pathToRegexp;\r\n\r\n/**\r\n * Match matching groups in a regular expression.\r\n */\r\nvar MATCHING_GROUP_REGEXP = /\\\\.|\\((?:\\?<(.*?)>)?(?!\\?)/g;\r\n\r\n/**\r\n * Normalize the given path string,\r\n * returning a regular expression.\r\n *\r\n * An empty array should be passed,\r\n * which will contain the placeholder\r\n * key names. For example \"/user/:id\" will\r\n * then contain [\"id\"].\r\n *\r\n * @param  {String|RegExp|Array} path\r\n * @param  {Array} keys\r\n * @param  {Object} options\r\n * @return {RegExp}\r\n * @api private\r\n */\r\n\r\nfunction pathToRegexp(path, keys, options) {\r\n  options = options || {};\r\n  keys = keys || [];\r\n  var strict = options.strict;\r\n  var end = options.end !== false;\r\n  var flags = options.sensitive ? '' : 'i';\r\n  var lookahead = options.lookahead !== false;\r\n  var extraOffset = 0;\r\n  var keysOffset = keys.length;\r\n  var i = 0;\r\n  var name = 0;\r\n  var pos = 0;\r\n  var backtrack = '';\r\n  var m;\r\n\r\n  if (path instanceof RegExp) {\r\n    while (m = MATCHING_GROUP_REGEXP.exec(path.source)) {\r\n      if (m[0][0] === '\\\\') continue;\r\n\r\n      keys.push({\r\n        name: m[1] || name++,\r\n        optional: false,\r\n        offset: m.index\r\n      });\r\n    }\r\n\r\n    return path;\r\n  }\r\n\r\n  if (Array.isArray(path)) {\r\n    // Map array parts into regexps and return their source. We also pass\r\n    // the same keys and options instance into every generation to get\r\n    // consistent matching groups before we join the sources together.\r\n    path = path.map(function (value) {\r\n      return pathToRegexp(value, keys, options).source;\r\n    });\r\n\r\n    return new RegExp(path.join('|'), flags);\r\n  }\r\n\r\n  if (typeof path !== 'string') {\r\n    throw new TypeError('path must be a string, array of strings, or regular expression');\r\n  }\r\n\r\n  path = path.replace(\r\n    /\\\\.|(\\/)?(\\.)?:(\\w+)(\\(.*?\\))?(\\*)?(\\?)?|[.*]|\\/\\(/g,\r\n    function (match, slash, format, key, capture, star, optional, offset) {\r\n      if (match[0] === '\\\\') {\r\n        backtrack += match;\r\n        pos += 2;\r\n        return match;\r\n      }\r\n\r\n      if (match === '.') {\r\n        backtrack += '\\\\.';\r\n        extraOffset += 1;\r\n        pos += 1;\r\n        return '\\\\.';\r\n      }\r\n\r\n      if (slash || format) {\r\n        backtrack = '';\r\n      } else {\r\n        backtrack += path.slice(pos, offset);\r\n      }\r\n\r\n      pos = offset + match.length;\r\n\r\n      if (match === '*') {\r\n        extraOffset += 3;\r\n        return '(.*)';\r\n      }\r\n\r\n      if (match === '/(') {\r\n        backtrack += '/';\r\n        extraOffset += 2;\r\n        return '/(?:';\r\n      }\r\n\r\n      slash = slash || '';\r\n      format = format ? '\\\\.' : '';\r\n      optional = optional || '';\r\n      capture = capture ?\r\n        capture.replace(/\\\\.|\\*/, function (m) { return m === '*' ? '(.*)' : m; }) :\r\n        (backtrack ? '((?:(?!/|' + backtrack + ').)+?)' : '([^/' + format + ']+?)');\r\n\r\n      keys.push({\r\n        name: key,\r\n        optional: !!optional,\r\n        offset: offset + extraOffset\r\n      });\r\n\r\n      var result = '(?:'\r\n        + format + slash + capture\r\n        + (star ? '((?:[/' + format + '].+?)?)' : '')\r\n        + ')'\r\n        + optional;\r\n\r\n      extraOffset += result.length - match.length;\r\n\r\n      return result;\r\n    });\r\n\r\n  // This is a workaround for handling unnamed matching groups.\r\n  while (m = MATCHING_GROUP_REGEXP.exec(path)) {\r\n    if (m[0][0] === '\\\\') continue;\r\n\r\n    if (keysOffset + i === keys.length || keys[keysOffset + i].offset > m.index) {\r\n      keys.splice(keysOffset + i, 0, {\r\n        name: name++, // Unnamed matching groups must be consistently linear.\r\n        optional: false,\r\n        offset: m.index\r\n      });\r\n    }\r\n\r\n    i++;\r\n  }\r\n\r\n  path += strict ? '' : path[path.length - 1] === '/' ? '?' : '/?';\r\n\r\n  // If the path is non-ending, match until the end or a slash.\r\n  if (end) {\r\n    path += '$';\r\n  } else if (path[path.length - 1] !== '/') {\r\n    path += lookahead ? '(?=/|$)' : '(?:/|$)';\r\n  }\r\n\r\n  return new RegExp('^' + path, flags);\r\n};\r\n"]}